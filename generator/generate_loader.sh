#!/bin/bash

if [[ "$(uname -s)" == "Darwin" ]]; then
  AWK=awk
  APPLE=true
else
  AWK=gawk
  APPLE=false
fi

CL_SUBDIR=OCDL

generator_dir=$(dirname "${0}")
generator_dir=$(cd "${generator_dir}"; pwd)

api_dir=$(cd "${generator_dir}"; cd ..; pwd)

out_dir="$(pwd)/opencl_loader"


function process_header() {
  local api_ver="${1}"
  local hdr_in="${2}"
  local hdr_out="${3}"
  local src_out="${4}"

  cat > "${hdr_out}" << EOF
//
// OpenCL-Loader generated replacement header for ${api_ver} ${hdr_in}
// $(date)
//
#pragma once
EOF

  #primary - include the initialize function decl
  ${AWK} -f "${generator_dir}"/process_header.sh -v src_out="${src_out}" -v src_out_decl="${src_out}.decl" -v hdr_out="${hdr_out}" "${hdr}"

  if [[ "${hdr_in}" == "opencl.h" ]]; then
    cat << EOF >> "${hdr_out}"
#ifdef __cplusplus
extern "C" {
#endif
#define OPENCL_LOADER_API_VERSION ${api_ver/opencl/}
/* pass NULL to use default library name */
/* overrideLibName should be complete file name e.g. OpenCL_Custom.dll or libOpenCL_custom.so */
extern int initialize_opencl(const char* /*overrideLibName*/);
#ifdef __cplusplus
}
#endif
EOF
  fi # opencl.h
}

function gen_loader() {
  local api_ver="${1}"
  local ver_out_dir="${out_dir}/${api_ver}"
  local include_out_dir="${ver_out_dir}/include/${CL_SUBDIR}"
  local src_out="${ver_out_dir}/src/${api_ver}_loader.c"

  if [[ ! -d "${api_ver}/CL" ]]; then
    echo "${api_ver} is not an OpenCL API directory." 1>&2
    return -1
  fi

  mkdir -p "${ver_out_dir}/src"
  mkdir -p "${include_out_dir}"

  cd "${api_ver}/CL"

  hpps=$(echo *.hpp)
  if [[ "${hpps}" == '*.hpp' ]]; then
    hpps=
  fi

  headers=
  includes=

  for hdr in *.h; do
    #skip d3d, dx, and intel headers for now
    if [[ ${hdr/d3d/} == ${hdr} && ${hdr/dx/} == ${hdr} && ${hdr/intel/} == ${hdr} ]]; then
      headers="${headers} ${hdr}"
      if [[ ${hdr} != "opencl.h" ]]; then
        includes="${includes}#include \"../include/${CL_SUBDIR}/${hdr}\""
      fi
    fi
  done

 #this version of specifying literal newline in replacement string required by OSX sed. works on gnu sed as well.
 includes=$(echo "${includes}" | sed 's:#:\'$'\n#:g')

  cat > "${src_out}" << EOF
//
// ${api_ver} loader source generated by OpenCL-Loader generator 
// $(date)
//
#include "../include/${CL_SUBDIR}/opencl.h"
${includes}

#if defined(_WIN32)
# define VC_EXTRALEAN 1
# include <windows.h>
# define LIB_PFX ""
# define LIB_SFX ".dll"
  typedef HMODULE libptr;
  typedef FARPROC funcptr;
  static libptr open_lib(const char* path) { return LoadLibrary( path ); }
  static funcptr find_lib_func(libptr lib, const char* name) { return GetProcAddress( lib, (char*)name ); }
# define NULL_LIB ((libptr)0)
#elif defined(__ANDROID__) || defined(__linux__) || defined(__APPLE__)
# include <dlfcn.h>
# define LIB_PFX "lib"
# if defined(__APPLE__)
#   define LIB_SFX ".dylib"
# else
#   define LIB_SFX ".so"
# endif
  typedef void* libptr;
  typedef void* funcptr;
  static libptr open_lib(const char* path) { return dlopen( path, RTLD_NOW | RTLD_LOCAL );}
  static funcptr find_lib_func(libptr lib, const char* name) { return dlsym( lib, name ); }
# define NULL_LIB ((libptr)0)
#else
# error Unsupported OS!
#endif

int initialize_opencl(const char* overrideLibName) {
  static int s_initted = 0;
  if ( s_initted ) return 1;

  libptr libopencl = NULL_LIB;

  if(overrideLibName)
  {
    libopencl = open_lib(overrideLibName);
  }
  else
  {
    libopencl = open_lib(LIB_PFX "OpenCL" LIB_SFX);
    if ( libopencl == NULL_LIB ) { libopencl = open_lib(LIB_PFX "opencl" LIB_SFX); }
  }
  
  if ( libopencl == NULL_LIB ) return 0;

  s_initted = 1;
EOF

  for hdr in ${headers}; do
    process_header "${api_ver}" "${hdr}" "${include_out_dir}/${hdr}" "${src_out}"
  done

  cat >> "${src_out}" << EOF
  return 1;
}
EOF

  cat "${src_out}.decl" >> "${src_out}"
  rm "${src_out}.decl"

  if [[ "${hpps}" ]]; then
    for hpp in ${hpps}; do
      cp -v "${hpp}" "${include_out_dir}/${hpp}"
    done
  fi

  # cl.hpp needs special attention - pointers to clGetXXX functions get passed around.
  # because function names now correspond to pointers instead of prototypes the syntax
  # used in those heades to refer to api function pointers is off by a level of indirection.
  # &::clGetXXX of a global pointer-to-func is a pointer pointer
  for hdr_name in cl.hpp; do # cl2.hpp; do # cl2.hpp appears to handle both cases via template magic
    hdr="${include_out_dir}"/${hdr_name}
    if [[ -f "${hdr}" ]]; then
      echo "// ${hdr_name} Processed by OpenCL-Loader Generator $(date)" > "${hdr}.fixed"
      sed 's/\&::clGet/::clGet/g' "${hdr}" | sed 's:#include <[Open]*CL/:#include <OCDL/:'>> "${hdr}.fixed"
      mv -f "${hdr}.fixed" "${hdr}"
    fi
  done

  cd  "${api_dir}"
}

cd "${api_dir}"

if [[ -n "${1}" ]]; then
  for api_ver in "${@}"; do
    if [[ ${api_ver} != "opencl_loader" ]]; then
      echo "Generating Loader for ${api_ver}"
      gen_loader "${api_ver}"
    fi
  done
else
  for api_ver in opencl*; do
    if [[ ${api_ver} != "opencl_loader" ]]; then
      echo "Generating OpenCL Loader for ${api_ver}"
      gen_loader "${api_ver}"
    fi
  done
fi
